<?phpclass uber_api_client{	private $user;	private $pass='';	private $error;	public $debug_last_resp;	public $debug_last_curl;	public function __construct($username = null,$api_token = null){		if($username != null && $api_token != null){			$this->pass=$username . ':' . $api_token;		}	}	private function genPostFields($data,$numeric_prefix = '',$_parent = null){		$postdata = array();		foreach ($data as $key => $val) 		{			if (!empty($_parent)) {				$key = $_parent .'['. $key .']';			} 			elseif (is_numeric($key)) {				$key = $numeric_prefix . $key;			}			if((is_object($val) || is_array($val))==true) {				$postdata = array_merge($postdata,$this->genPostFields($val,$numeric_prefix,$key));			} 			else {				$postdata[$key] = $val;			}		}		return $postdata;	}	private function isGZipEncoded($data){		return (strcmp(substr($data,0,2),"\x1f\x8b") == 0);	}	function call($url,$method = 'uber.method_list',$params = array(),$debug=false){		//Clear the error		$this->error = '';				//Prepare the request 		$curl = curl_init($url . '/?method=' . urlencode($method));		curl_setopt($curl,CURLOPT_POST,1);		curl_setopt($curl,CURLOPT_RETURNTRANSFER, 1);		curl_setopt($curl,CURLOPT_FOLLOWLOCATION,1);		curl_setopt($curl,CURLOPT_MAXREDIRS,     2);		curl_setopt($curl,CURLOPT_POSTFIELDS, $this->genPostFields($params));			curl_setopt($curl, CURLOPT_USERPWD, ($this->pass != '' ? $this->pass : ''));    	curl_setopt($curl, CURLOPT_TIMEOUT, 10); //timeout in seconds        curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);        curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 0);		//Get the request		$response = curl_exec($curl);		//if($debug){echo $url . '/?method=' . urlencode($method); echo curl_error ( $curl ); echo $response;}		        if($debug){			$this->debug_last_curl=curl_error($curl); 			$this->debug_last_resp=$response; 		}		$contentType= curl_getinfo($curl,CURLINFO_CONTENT_TYPE);        $errorNb = curl_errno($curl);        $errorMsg = curl_strerror($errorNb);        $error = curl_error($curl);        $info = curl_getinfo($curl);		//Close the request		curl_close($curl);		//Process the data		$response = ($this->isGZipEncoded($response)==true ? (function_exists('gzdecode') == true ? gzdecode($response) : $this->gzdecodeManual($response)) : $response); //Un GZip if needed		//If it's JSON data, other types of data don't need processing so they will just pass though		if($contentType=='application/json'){            try{                $response=json_decode($response,true);            }            catch(Exception $e){                //($e); die();                $response = null;            }			if($response == null){				$this->error = 'JSON data can not be encoded';				$response=false;			}			elseif (empty($response['status'])){				$this->error = $response['error_message'] . ' - ' . $response['error_code'];				$response= false;			}                        elseif(!$response['status'])                        {                            $this->error = $response['error_message'] . ' - ' . $response['error_code'];                            $response = false;                        }			else{				$response=$response["data"];			}					//Handle logging			if($_COOKIE["DEBUG"]=="TRUE"){				$myfile = fopen("debug.log", "a");				$entry = 					"URL: " . $url . '/?method=' . urlencode($method) . "\n" .					"POST Fields: " . print_r($this->genPostFields($params),true) . "\n" .					"Response: " . print_r($response,true) . "\n" .					"---------------------------------\n";									fwrite($myfile, $entry);			}		}		return $response;	}		function gzdecodeManual($data) {	  $len = strlen($data);	  if ($len < 18 || strcmp(substr($data,0,2),"\x1f\x8b")) {		return null;  // Not GZIP format (See RFC 1952)	  }	  $method = ord(substr($data,2,1));  // Compression method	  $flags  = ord(substr($data,3,1));  // Flags	  if ($flags & 31 != $flags) {		// Reserved bits are set -- NOT ALLOWED by RFC 1952		return null;	  }	  // NOTE: $mtime may be negative (PHP integer limitations)	  $mtime = unpack("V", substr($data,4,4));	  $mtime = $mtime[1];	  $xfl   = substr($data,8,1);	  $os    = substr($data,8,1);	  $headerlen = 10;	  $extralen  = 0;	  $extra     = "";	  if ($flags & 4) {		// 2-byte length prefixed EXTRA data in header		if ($len - $headerlen - 2 < 8) {		  return false;    // Invalid format		}		$extralen = unpack("v",substr($data,8,2));		$extralen = $extralen[1];		if ($len - $headerlen - 2 - $extralen < 8) {		  return false;    // Invalid format		}		$extra = substr($data,10,$extralen);		$headerlen += 2 + $extralen;	  }	  $filenamelen = 0;	  $filename = "";	  if ($flags & 8) {		// C-style string file NAME data in header		if ($len - $headerlen - 1 < 8) {		  return false;    // Invalid format		}		$filenamelen = strpos(substr($data,8+$extralen),chr(0));		if ($filenamelen === false || $len - $headerlen - $filenamelen - 1 < 8) {		  return false;    // Invalid format		}		$filename = substr($data,$headerlen,$filenamelen);		$headerlen += $filenamelen + 1;	  }	  $commentlen = 0;	  $comment = "";	  if ($flags & 16) {		// C-style string COMMENT data in header		if ($len - $headerlen - 1 < 8) {		  return false;    // Invalid format		}		$commentlen = strpos(substr($data,8+$extralen+$filenamelen),chr(0));		if ($commentlen === false || $len - $headerlen - $commentlen - 1 < 8) {		  return false;    // Invalid header format		}		$comment = substr($data,$headerlen,$commentlen);		$headerlen += $commentlen + 1;	  }	  $headercrc = "";	  if ($flags & 2) {		// 2-bytes (lowest order) of CRC32 on header present		if ($len - $headerlen - 2 < 8) {		  return false;    // Invalid format		}		$calccrc = crc32(substr($data,0,$headerlen)) & 0xffff;		$headercrc = unpack("v", substr($data,$headerlen,2));		$headercrc = $headercrc[1];		if ($headercrc != $calccrc) {		  return false;    // Bad header CRC		}		$headerlen += 2;	  }	  // GZIP FOOTER - These be negative due to PHP's limitations	  $datacrc = unpack("V",substr($data,-8,4));	  $datacrc = $datacrc[1];	  $isize = unpack("V",substr($data,-4));	  $isize = $isize[1];	  // Perform the decompression:	  $bodylen = $len-$headerlen-8;	  if ($bodylen < 1) {		// This should never happen - IMPLEMENTATION BUG!		return null;	  }	  $body = substr($data,$headerlen,$bodylen);	  $data = "";	  if ($bodylen > 0) {		switch ($method) {		  case 8:			// Currently the only supported compression method:			$data = gzinflate($body);			break;		  default:			// Unknown compression method			return false;		}	  } else {		// I'm not sure if zero-byte body content is allowed.		// Allow it for now...  Do nothing...	  }	  // Verifiy decompressed size and CRC32:	  // NOTE: This may fail with large data sizes depending on how	  //       PHP's integer limitations affect strlen() since $isize	  //       may be negative for large sizes.	  if ($isize != strlen($data) || crc32($data) != $datacrc) {		// Bad format!  Length or CRC doesn't match!		return false;	  }	  return $data;	}	function getError(){		return ($this->error == '' ? false : $this->error);	}};